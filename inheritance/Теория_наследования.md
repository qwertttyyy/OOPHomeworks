
# Теория урока: Наследование в Python

---

## Что такое наследование?

**Наследование** — это механизм в объектно-ориентированном программировании, который позволяет создать новый класс (производный), унаследовав свойства и методы уже существующего класса (базового).

### Основные понятия

- **Базовый класс** (родительский класс) — это класс, от которого наследуются свойства и методы.
- **Производный класс** (дочерний класс) — это новый класс, который наследует свойства и методы базового класса.

### Зачем нужно наследование?

- **Повторное использование кода**: Базовый класс содержит общие атрибуты и методы, которые могут быть использованы во всех производных классах.
- **Расширение функциональности**: Производный класс может добавлять новые методы и свойства или изменять поведение унаследованных методов.
- **Организация кода**: Структура программы становится более логичной и упрощает поддержку кода.

---

## Простой пример наследования

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def display_info(self):
        print(f"Имя: {self.name}, Возраст: {self.age}")

class Student(Person):
    def __init__(self, name, age, student_id):
        super().__init__(name, age)  # Вызов конструктора базового класса
        self.student_id = student_id

    def display_info(self):
        super().display_info()  # Вызов метода базового класса
        print(f"Студенческий билет: {self.student_id}")

student = Student("Иван", 20, "S12345")
student.display_info()
```

**Вывод**:
```
Имя: Иван, Возраст: 20
Студенческий билет: S12345
```

---

## Переопределение методов

**Переопределение методов** — это процесс, при котором метод базового класса изменяется в производном классе. Производный класс может использовать новый метод вместо унаследованного.

### Когда нужно переопределение?

- Если поведение базового класса не полностью соответствует задачам производного класса.
- Чтобы добавить новую функциональность или изменить логику унаследованного метода.

### Пример переопределения метода

```python
class Animal:
    def speak(self):
        return "Этот животное не издает звуков"

class Dog(Animal):
    def speak(self):
        return "Гав!"

class Cat(Animal):
    def speak(self):
        return "Мяу!"

dog = Dog()
cat = Cat()
print(dog.speak())  # Гав!
print(cat.speak())  # Мяу!
```

---

## Функция `super()`

Функция `super()` используется для вызова методов и атрибутов базового класса из производного класса. Она особенно полезна для:

- Вызова конструктора базового класса.
- Вызова переопределенных методов базового класса.

### Пример использования `super()`

```python
class Employee:
    def __init__(self, name, salary):
        self.name = name
        self.salary = salary

    def display_info(self):
        print(f"Имя: {self.name}, Зарплата: {self.salary}")

class Manager(Employee):
    def __init__(self, name, salary, department):
        super().__init__(name, salary)  # Вызов конструктора базового класса
        self.department = department

    def display_info(self):
        super().display_info()  # Вызов метода базового класса
        print(f"Отдел: {self.department}")

manager = Manager("Анна", 70000, "IT")
manager.display_info()
```

**Вывод**:
```
Имя: Анна, Зарплата: 70000
Отдел: IT
```

---

## Наследование и множественное наследование

### Что такое множественное наследование?

Множественное наследование позволяет производному классу наследовать свойства и методы сразу от нескольких базовых классов.

### Пример множественного наследования

```python
class A:
    def __init__(self):
        self.attr_a = "Атрибут из класса A"

class B:
    def __init__(self):
        self.attr_b = "Атрибут из класса B"

class C(A, B):
    def __init__(self):
        super().__init__()  # Вызов __init__ из A, затем из B
        self.attr_c = "Атрибут из класса C"

    def display_attributes(self):
        print(self.attr_a)
        print(self.attr_b)
        print(self.attr_c)

obj = C()
obj.display_attributes()
```

**Вывод**:
```
Атрибут из класса A
Атрибут из класса B
Атрибут из класса C
```

### Как работает `super()` при множественном наследовании?

`super()` вызывает методы родителей в порядке, определяемом цепочкой MRO (Method Resolution Order). Цепочку можно посмотреть через `__mro__`:

```python
print(C.__mro__)
```

**Вывод**:
```
(<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>)
```

---

## Заключение

- Наследование упрощает организацию кода и позволяет повторно использовать функциональность базовых классов.
- Переопределение методов помогает адаптировать базовый функционал к задачам производных классов.
- Функция `super()` упрощает вызов методов и конструкторов родительских классов, особенно при множественном наследовании.

Теперь вы знаете, как использовать наследование, переопределение методов и `super()` для создания гибкой и структурированной программы!
